# -*- coding: utf-8 -*-
"""Copy of 01 Python Fundamentals, Part 1 (Workbook).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-OzZtxlC9_yfjpkP8PXYoX29-qOAOsSC

# PYTHON FUNDAMENTALS, Part 1 (Workbook)

[CC BY 4.0](https://creativecommons.org/licenses/by/4.0/)

## Credits

Most code snippets and explanatory texts from:
- Charles Russel Severance's [Python for Everybody](https://www.py4e.com/) lecture slides
  -  Unless annotated as indicated below, text and code came from this source. Additionally, they could be explicitly indicated by the marker `[PES]`

and
- Charles Russel Severance's [Python for Everybody - Online HTML Book](https://www.py4e.com/html3/)
  - Notes and codes from this source are indicated by this the marker `[PEW]`

Additional codes and comments from:

- J.R. Johansson's [Introduction to Scientific Computing with Python](http://github.com/jrjohansson/scientific-python-lectures)
  - Notes and codes from this source are indicated by this the marker `[JRJ]`

# Before you begin

First, make a copy of this notebook so that you can make changes as you please. Run and edit the copy instead of this original notebook. To copy this notebook, go to `File|Make a Copy`.

If this notebook is already a copy of the original, clear all outputs in this notebook. Go to the Menu and click on `Cell| All Outputs| Clear`. Once this is done, you're ready to go.

# Suggestions for Learning

- Code snippets in Raw Cells are meant to be written by Beginners.
- Code snippets in Code Cells are for illustration purposes. They are meant to be executed by both Beginners and more experienced Learners. (Beginners, may wish to also type them, if they so choose).

For better learning experience, the following are suggested:

### For Beginners
1. Create a new Code Cell below the code snippets inside Raw Cells (Insert Cell below then convert the cell type to Code Cell).
2. Go to your newly-created Code Cell and re-type what you see in the code snippet (don't copy-paste)
3. Execute (and experiment) on the Code Cell.
4. Remember to learn by doing (not just by reading or seeing)

### For Coders
1. If you are not yet familiar with the concept, follow Steps 1&2 of the Instructions for Beginners
2. If you are already familiar with the concept being presented, convert the Raw Cell into a Code Cell.
3. Execute (and experiment) on the Code Cell.
4. Learn the "adjacent concepts", e.g. read related documentation
5. Help your classmates, because teaching is a wonderful way to learn.

### For All
* Make this your personal notebook.
    * Add your own text annotations in Markup Cells.
    * Add comments to parts of code that you find difficult to understand
    * Breakdown difficult code into several small pieces (maybe, several Code Cells) that are easier to understand

<a id='contents'></a>

# TABLE OF CONTENTS

[Terminal Commands and Magic Commands (Optional)](#chapter0)<br>
[Chapter 1 Introduction](#chapter1)<br>
[Chapter 2 Variables, Expressions, and Statements](#chapter2)<br>
[Chapter 3 Conditional Execution](#chapter3)<br>
[Chapter 4 Functions](#chapter4)<br>
[Chapter 5 Iterations](#chapter5)<br>

<a id='chapter0'></a>

# Terminal Commands and Magic Commands (Optional)

Below are some useful tools for doing work in Jupyter. Although they are executed in Code Cells **they are not python code** and could not be used in python programs. This section is not in [PES] nor [PEW]

## Terminal Commands
You can execute terminal (or shell) commands within Jupyter Notebooks by prepending them with the exclamation mark

### Windows Terminal Commands

If you are running Windows, you could try the following commands

#### `Directory` Command
Shows current directory and its contents

!dir

#### `Type` Command
Displays the contents of the file to the screen

!type words.txt

### Linux and Mac Commands

#### `pwd` Command
Prints the name of the current directory

!pwd

#### `ls` command
Prints a list of files in the current directory

!ls

#### `cat` command
Displays the contents of a file to screen. `Cat` is short for con**cat**enate.

!cat words.txt

!cat words.py

## Magic Commands
Running Jupyter with a python kernel allows you to use Magic commands that allows you to do many useful things.

#### load
Load magic allows you to load the contents of a file to a cell

# %load words.py
name = input('Enter file:')
handle = open(name, 'r')
counts = dict()

for line in handle:
    words = line.split()
    for word in words:
        counts[word] = counts.get(word, 0) + 1

bigcount = None
bigword = None
for word, count in list(counts.items()):
    if bigcount is None or count > bigcount:
        bigword = word
        bigcount = count

print(bigword, bigcount)

#### writefile
Write the contents of a cell to a file
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile helloworld.py #creating a helloworld.py file
# print('Hello world!')

"""Let's check if the file is written:

# Run this cell if you're using Mac or Linux
!cat helloworld.py
"""

# Run this cell if you're using Windows
!type helloworld.py

"""#### run
Runs a python script or jupyter notebook and display the contents.

%run helloworld.py
"""

#run simple_expressions.ipynb

"""#### who
Displays a list of in-use variables
"""

# Commented out IPython magic to ensure Python compatibility.
# %who

"""[TABLE OF CONTENTS](#contents)

<a id='chapter1'></a>

# CHAPTER 1 - Introduction

Execute the code the code below.
"""

print('Hello world!') #displaying the Hello World

x = 6
print(x) #displaying a numerical value 6

x = 6
y = x * 7 # multiplying the content of object x to 7
print(y)

"""In Jupyter (and in the Python interpreter) you can inspect the value of a variable by simply typing its name."""

y

"""Execute the code below; no need to re-type it. Type `words.text` when prompted for a file.

name = input('Enter file:')
handle = open(name, 'r')
counts = dict()

for line in handle:
    words = line.split()
    for word in words:
        counts[word] = counts.get(word, 0) + 1

bigcount = None
bigword = None
for word, count in list(counts.items()):
    if bigcount is None or count > bigcount:
        bigword = word
        bigcount = count

print(bigword, bigcount)

# Code: http://www.py4e.com/code3/words.py

##  Whitespaces
The non-printing characters space and tab are called whitespaces. Python interprets whitespaces in the following way:
* whitespaces **after** the first visible character: These are ignored by python.
    * Use whitespaces to make your code readable.
* whitespaces **before** the first visible character (or indentation whitespaces): have a special meaning in python.  Specifically, it tells python how to group certain lines of code together.
    * Be careful in mixing spaces and tabs as this could confuse you (and python) what you are really trying to do.
    * If you are using a text editor or an Integrated Development Environment, use one with an option to convert Tabs to Spaces. Spyder has that feature. (More on these below).
   
<br>

##  Code Comments
Comments in python are indicated by the `#` character. Python ignores anything written **after** the `#` character.

You can use code comments to
* Explain the important or difficult parts of your program
* Temporarily disable parts of your program

<br>
"""

#The code below will not be executed
#print('Hello World')

"""You can use code comments to
* Explain the important or difficult parts of your program
* Temporarily disable parts of your program
<br>
"""

# The text below tries to explain what the code is doing
# Tell python to say "Hello world" in Japanese (romaji)
print('romaji!')

#あ

#The code below will only greet in English
print('Hello World!')
#print('Sekai konnichiwa!')

#あ

"""## EXERCISES

#### Exercise 1

Each line of code below contains an error. Fix the error and explain in a comment the reason for the error.
"""

print("Hello world!")

print("Hello world!")

print("Hello world!")

print("Hello world!")

"""#### Exercise 2
What is the output of the code below? [PEW]
"""

x = 43
x = x + 1
print(x)

"""#### Exercise 3
The code below contains an error. Fix the error and explain in a comment the reason for the error.
"""

x = 43
x = x + 1
print(x)

"""[TABLE OF CONTENTS](#contents)

<a id='chapter2'></a>

# CHAPTER 2 - Variables, Expressions, and Statements

##  Values or Literals

A **value** is one of the basic things a program works with, like a letter or a number.  The values we have seen so far are `1`, `2`, and `"Hello, World!"`

Another name for values are **literals**.
"""



"""print(2)

*   List item
*   List item

2

'Hello world!'

print('Hello World')

##  Types

Values belong to different **types**: `2` is an **integer**, and `"Hello, World!"` is a **string**, so called because it contains a "string" of letters. You (and the interpreter) can identify strings because they are enclosed in quotation marks.

type(2)

Python strings can be enclosed in single quote(`'`) or double quotes (`"`). The back quote (the character that shares the key with tilde `~`) cannot be used to identify strings.

type('Hello, World!')

type(3.2)

type('17')

type('3.2')

When you type a large integer, you might be tempted to use commas between groups of three digits, as in 1,000,000. This is not a legal integer in Python, but the code below is legal :

print(1,000,000)

## Reserved Words

These are words that have very special meaning to Python. When Python sees these words in a Python program, they have one and only one meaning to Python. You cannot use any of Python's reserved words as a name for a variable.

and       del       global      not       with
    as        elif      if          or        yield
    assert    else      import      pass
    break     except    in          raise
    class     finally   is          return
    continue  for       lambda      try
    def       from      nonlocal    while

You cannot use reserved words as names for variables and functions. (More on these below)

The following code cells will produce an error.

class = 2121

elif = 'Legolas'

## Variable Names

A variable is a named place in the memory where a programmer can store data and later retrieve the data using the variable “name”.

x = 12.2
print(x)

y = 14
y

You can change the contents of a variable in a later statement.

x = 100
x

### Python Variable Name Rules

- Must start with a letter or underscore (`_`)
- Must consist of letters, numbers, and underscores
- Are case-sensitive

Good:      spam    eggs   spam23    _speed
    Bad:       23spam  #sign  var.12
    Different: spam    Spam   SPAM

The code below is perfectly valid, although very confusing because of the variable names given.

x1q3z9ocd = 35.0
x1q3z9afd = 12.50
x1q3p9afd = x1q3z9ocd * x1q3z9afd
print(x1q3p9afd)

This one is much easier to understand.

a = 35.0
b = 12.50
c = a * b
print(c)

Better still, use meaningful variable names.

hours = 35.0
rate = 12.50
pay = hours * rate
print(pay)

The Python convention is to use **lowercase** for variable names. **underscores** are used to make long variable names more readable.

## Statements and Expressions

#### Statements
Statements contain a complete instruction that Python can execute. They are equivalent to a sentences in a human language.

####  Expressions
Expressions are a combination of variables, literals and operators.  The python interpreter can understand what they mean, but they do not give a complete instruction. Expressions are used in statements. They are equivalent to a phrases in a human language.

If you type an expression in the python interpreter python evaluates it and displays the result.

Try typing the following statements to see what they do

5

x = 5

But in a script, an expression all by itself doesn't do anything! This is a common source of confusion for beginners.

Expressions have to be part of a statement to accomplish something useful.

#### Assignment Statements

- We assign a value to a variable using the assignment statement (`=`)
- An assignment statement consists of an expression on the right-hand side and a variable to store the result

#### Assignment statement

x = 0.6
x

#### Assignment statement with an expression

x = 3.9 *  x  * ( 1  -  x )
x

####  Statement with a function

print(x)

### Operators and operands

**Operators** are special symbols that represent computations like addition and multiplication. The values the operator is applied to are called `operands`.

#### Addition

5 + 2

#### Subtraction

5 - 2

#### Multiplication

5 * 2

#### Division

5 / 2

#### Integer Division

Gets the whole number portion only of a division expression.

5 // 2

##### Note on Python 2<br>
 [JRJ]
> The `/` operator always performs a floating point division in Python 3.x.
This is not true in Python 2.x, where the result of `/` is always an integer if the operands are integers.
to be more specific, `1/2 = 0.5` (`float`) in Python 3.x, and `1/2 = 0` (`int`) in Python 2.x (but `1.0/2 = 0.5` in Python 2.x).

#### Modulo

Gets the whole remainder portion only of a division expression.

5 % 2

#### Power or Exponentiation

Compute 5 raised to the 2nd power (or 5 squared):

5**2

## Order of Evaluation

When we string operators together - Python must know which one to do first. This is called **operator precedence**.

Which operator “takes precedence” over the others in the expression below?

x = 1 + 2 * 3 - 4 / 5 ** 6
x

### Operator Precedence Rules

Highest precedence rule to lowest precedence rule:
1. Parentheses are always respected
2. Exponentiation (raise to a power)
3. Multiplication, Division, and Modulo
4. Addition and Subtraction
5. Left to right

#### Acronym: P-E-MMD-AS
1. Parenthesis
2. Exponentiation
3. Multiplication /  Modulo / Division
4. Addition / Subtraction

Left to Right (because it's not Japanese, which is traditionally right to left)

#### Tips

* Keep mathematical expressions simple enough that they are easy to understand.  
* Assign intermediate variables to make expressions simpler and clearer

## Operations Depending on Type

python can perform operations which are suitable to the types of the variables, literals and constants appearing in an expression.

####  `+` operator: integer addition

d = 1 + 4
d

#### `+` operator: string concatenation

e = 'hello ' + 'there'
e

However, operations on different types are prohibited

e = 'hello ' + 'there'
e = e + 1

type(e)

type(1)

### Several Types of Numbers

Numbers have two main types
-  Integers are whole numbers: -14, -2, 0, 1, 100, 401233
-  Floating Point Numbers have  decimal parts:  -2.5 , 0.0, 98.6, 14.0

There are other number types - they are variations on float and integer

### Type Conversions

When you put an integer and floating point in an expression, the integer is implicitly converted to a float.

x = 1 + 2.5
print(x)
print(type(x))

#あ

### Conversions from String

- You can also use `int()` and `float()` to convert between strings and integers
- You will get an `error` if the string does not contain numeric characters

string_val = '123'
type(string_val)

The code below adds an integer to a string and will thus produce an error.

print(string_val+1)

Now let's get the integer equivalent of the string using `int()`

int_val = int(string_val)
type(int_val)

int_val

print(int_val+1)

The code below tries to convert a string with non-numeric content to an integer.

lotto_jackpot_str = '1,180,622,508'
lotto_jackpot_val = int(lotto_jackpot_str)

#あ

## User Input

- We can instruct Python to pause and read data from the user using the `input()`  function
- The `input()` function returns a string

name = input('Who are you?')
print('Welcome', name)

### Converting User Input

If we want to read a number from the user, we must convert it from a string to a number using a **type conversion** function

inp = input('Europe floor?')
usf = int(inp) + 1
print('US floor', usf)

## Debugging
[PEW]

### Syntax Error

At this point, the syntax error you are most likely to make is an illegal variable name, like `class` and `yield`, which are keywords, or `odd~job` and `US$`, which contain illegal characters.

If you put a space in a variable name, Python thinks it is two operands without an operator:

bad name = 5

month = 09

For syntax errors, the error messages don't help much. The most common messages are `SyntaxError: invalid syntax` and `SyntaxError: invalid token`, neither of which is very informative.

#### Runtime Errors

The runtime error you are most likely to make is a `name 'some_variable_name' is not defined` that is, trying to use a variable before you have assigned a value. This can happen if you spell a variable name wrong:

principal = 327.68
interest = principle * rate

#### Logic or Semantic Errors

Suppose you want to evaluate `1 divided by twice of pi`, and you wrote the code below, what you would get instead is one-half of pi.  You will not have a syntax error nor a run time error, but your answer will be incorrect. To fix this problem, make sure you remember the operator precedence. Also, using parenthesis for expression clarity can help.

pi = 3.1415
1 / 2*pi

Corrected expressions

1/(2*pi)

or, you can use an intermediary variable (although this would be more advisable for more complex expressions)

twice_of_pi = 2 * pi
1/twice_of_pi

#あ

## Final Words

- Learning a programming language could be frustrating and exciting at the same time
  - Much like learning a new language
  - We could be overwhelmed by the seemingly endless things we have to learn
- Tips
  - Learn by doing
  - Experiment
  - Get used to seeing sytax errors, and fixing them
  - If something is too complicated, break it apart

## EXERCISES

#### Exercise 1

Write a program that uses input to prompt a user for their name and then welcomes them.
```
Enter your name: louisa

```
# This is formatted as code
```


Hello louisa

```
# This is formatted as code
```


```

[PEW] E2.2
"""



"""#### Exercise 2

Write a program to prompt the user for hours and rate per hour to compute gross pay.
```
Enter Hours: 35
Enter Rate: 2.75
Pay: 96.25

```
# This is formatted as code
```


```

[PEW] E2.3
"""

hour = 35
rate = 2.7
pay = 96.25
hour + rate
print(hour + rate)
print(pay)

"""#### Exercise 3

Assume that we execute the following assignment statements:
```python
width = 17
height = 12.0
```
For each of the following expressions, write the value of the expression and the type (of the value of the expression).
```python
width//2
width/2.0
height/3
1 + 2 * 5
```

[PEW] E2.4

#### Exercise 4

Write a program that uses input to prompt a user for a number and then outputs the square of the number
```
Enter a number: 3
The square of 3 is 9
```

## CHALLENGE

Write a program which prompts the user for a Celsius temperature, convert the temperature to Fahrenheit, and print out the converted temperature.

[PEW] E2.5

[TABLE OF CONTENTS](#contents)

<a id='chapter3'></a>

# CHAPTER 3 - Conditional Execution

## Boolean Expressions

A **boolean expression** is an expression that is either true or false. The following examples use the operator `==`, which compares two operands and produces True if they are equal and False otherwise:

The next two cells are assignment statements.

x = 5

y = 6

The next three cells are boolean expressions. Notice the double-equal sign.

x == 5

y == 6

x == y

`True` and `False` are special values that belong to the class `bool`; they are not strings:

type(True)

type(False)

### Comparison Operators

The `==` operator is one of the **comparison operators**; the others are listed below. Comparison operators look at variables but do not change the variables.

x != y               # x is not equal to y

x > y                # x is greater than y

x < y                # x is less than y

x >= y               # x is greater than or equal to y

x <= y               # x is less than or equal to y

x is y               # x is the same as y

x is not y           # x is not the same as y

### Logical Operators

There are three **logical operators**: `and`, `or`, and `not`. The semantics (meaning) of these operators is similar to their meaning in English.

True and True

True and False

False and False

False and True

True or False

not True

not False

(x==5) and (x < y)

(x>=0) and (y<5)

(x>=0) or (y<5)

## Boolean Expressions and  Program Flow

Boolean expressions ask a question and produce a `Yes` or `No` result which we use to control program flow

x = 5
if x < 10:
    print('Smaller')
if x > 20:
    print('Bigger')

print('End')

## One-Way Decisions

In order to write useful programs, we almost always need the ability to check conditions and change the behavior of the program accordingly. Conditional statements give us this ability. The simplest form is the **`if`** statement:

x = 5
print('Before 5')
if  x == 5:
    print('Is 5')
    print('Is Still 5')
    print('Third 5')
print('Afterwards 5')
print('Before 6')
if x == 6:
    print('Is 6')
    print('Is Still 6')
    print('Third 6')
print('Afterwards 6')

### A Side Note on Indentation

- Increase indent  after an `if` statement
- Maintain indent to indicate the scope of the block (which lines are affected by the `if` statement)
- Reduce indent back to the level of the `if` statement to indicate the end of the block
- Blank lines are ignored - they do not affect indentation
- Comments on a line by themselves are ignored with regard to indentation

#### Tabs and Spaces
Indentation is important in Python and could affect how a code behaves
- Jupyter automatically uses spaces
- Spyder can turn tabs into spaces - make sure this feature is enabled


#### Mixed use of Tabs and Spaces
 Below is a sample text  in Jupyter copied from an existing code. Even though the code is visually alligned,  the Python kernel complains because: The first `print` statement was made with spaces, while the next two `print` statements were made with tabs.

print('Before 5')
if  x == 5 :
    print('Is 5')         #this is indented with spaces
	print('Is Still 5')   #this is indented with a tab  (notice the arrow marking)
	print('Third 5')      #this is indented with a tab  (notice the arrow marking)

#あ

##  Nested Decisions

One conditional can also be nested within another.

x = 42
if x > 1:
    print('More than one')
    if x < 100:
        print('Less than 100')
print('All done')

### Two-way Decisions with `else`

x = 4

if x > 2 :
    print('Bigger')
else :
    print('Smaller')

print('All done')

### Multi-way with `elif`

x = 0
if x < 2 :
    print('small')
elif x < 10 :
    print('Medium')
else :
    print('LARGE')
print('All done')

# No Else
x = 5
if x < 2 :
    print('Small')
elif x < 10 :
    print('Medium')

print('All done')

if x < 2 :
    print('Small')
elif x < 10 :
    print('Medium')
elif x < 20 :
    print('Big')
elif x < 40 :
    print('Large')
elif x < 100:
    print('Huge')
else :
    print('Ginormous')

In the code below, which will never print regardless of the value for x?

if x < 2 :
    print('Below 2')
elif x < 20 :
    print('Below 20')
elif x < 10 :
    print('Below 10')
else :
    print('Something else')

##  Some advice on using `if` statements
- Check all `if` and `elif` statements if they need an `else` part. If you are not sure, then add one, where you print a message, perhaps, with the value of the evaluation expression.
- Although it's possible to have lots of nested conditional statements, try to limit the levels to 1 or 2. If having several levels is really necessary, consider making a `function` for some of the levels (see next chapter).
- Keep **decision expressions** simple. Complicated decision expressions could be transformed into intermediate variables with meaningful names.

##  Catching exceptions using `try` and `except`

The code below gets an input and computes its square. Run the code and enter a non-numeric string of characters when prompted for a number.

num_str = input('Enter a number:')
num_val = float(num_str)
print('The square of '+num_str+' is')
print(num_val*num_val)

The code produced a `ValueError` because the string input could not be converted into float.

There is a conditional execution structure built into Python to handle expected and unexpected errors called `try / except`. The idea of `try and except` is that you know that some sequence of instruction(s) may have a problem and you want to add some statements to be executed if an error occurs. These extra statements (the `except` block) are ignored if there is no error.

You can think of the `try and except` feature in Python as an "insurance policy" on a sequence of statements.

The code above can be re-written in the following way using a `try-except` block.

num_str = input('Enter a number:')
try:
    num_val = float(num_str)
    print('The square of '+num_str+' is')
    print(num_val*num_val)
except:
    print('Input error. Try again next time.')

#あ

Python starts by executing the sequence of statements in the `try` block. If all goes well, it skips the except block and proceeds. If an exception occurs in the `try` block, Python jumps out of the `try` block and executes the sequence of statements in the `except` block.

Handling an exception with a `try` statement is called **catching an exception**. In this example, the `except` clause prints an error message. In general, catching an exception gives you a chance to fix the problem, or try again, or at least end the program gracefully.

## Final Words

Conditional expressions help us draw a map for a programming task by giving us the capability to branch out to several options.

## EXERCISES

#### Exercise 1

In the code below, which will never print regardless of the value for x? Edit the code to correct the error.

```python
if x > 0 :
    print('Above 0')
elif x >  10 :
    print('Above 10')
elif x > 50 :
    print('Above 50')
elif x >  20 :
    print('Above 20')
else :
    print('Something else')
```

#### Exercise 2

Write your salary computation to give an employee 1.5 times the hourly rate for hours worked above 40 hours. Example:

    Enter Hours: 45
    Enter Rate: 10
    Pay: 475.0
    
[PEW] E3.2

## CHALLENGE

Write a program to prompt for a score between 0 and 100 and print a grade using the following table:

    Score           Grade
    [ 97, 100]      1.0
    [ 93,  97)		1.25
    [ 89,  93)		1.5
    [ 85,  89)		1.75
    [ 81,  85)		2.0
    [ 77,  81)		2.25
    [ 74,  77)		2.5
    [ 0,   74)		3.0

Adapted from [PEW] E3.3
<br>

[TABLE OF CONTENTS](#contents)

<a id='chapter4'></a>

# CHAPTER 4 - Functions

In the context of programming, a **function** is a named sequence of statements that performs a computation. When you define a function, you specify the **name** and the **sequence of statements**. Later, you can **call** the function by name. [PEW]

It's important to learn the concept behind `functions` as most of the tools you will be using functions made by other people.

## Functions as Stored (and reused) Steps

Below is a function named `friend`.

def friend():
    print("Winter, spring, summer or fall.")
    print("I'll be there.")

#あ

Once the function `friend` is defined, we can `call` it anytime in our code.

Run the code below 5 times, for each time, change set the value of the variable `season` to `winter`, `spring`, `summer`, `fall`, and `rainy`

season = 'winter'

if season =='winter':
    friend()
    print("Yes, I will.")
elif season == 'spring':
    friend()
    print("Oh, yeah!")
elif season is 'summer':
    friend()
    print("Ain't it good to know?")
elif season is 'fall':
    friend()
    print("You've got a friend!")
else:
    print('Hu u?')

#あ

## Python Functions

There are two kinds of functions in Python.
-  Built-in functions that are provided as part of Python - `print()`, `input()`, `type()`, `float()`, `int()` ...
-  Functions that we define ourselves and then use

## Built-in Functions

Below is a list of built-in Python functions.

abs()
    all()
    any()
    ascii()
    bin()
    bool()
    breakpoint()
    bytearray()
    bytes()
    callable()
    chr()
    classmethod()
    compile()
    complex()
    delattr()
    dict()
    dir()
    divmod()
    enumerate()
    eval()
    exec()
    filter()
    float()
    format()
    frozenset()
    getattr()
    globals()
    hasattr()
    hash()
    help()
    hex()
    id()
    input()
    int()
    isinstance()
    issubclass()
    iter()
    len()
    list()
    locals()
    map()
    max()
    memoryview()
    min()
    next()
    object()
    oct()
    open()
    ord()
    pow()
    print()
    property()
    range()
    repr()
    reversed()
    round()
    set()
    setattr()
    slice()
    sorted()
    staticmethod()
    str()
    sum()
    super()
    tuple()
    type()
    vars()
    zip()
    __import__()

You don't have to memorize all of the functions above. You can do a deeper study on any of them once you have to start using it.

#### Warning

Make sure that you don't use any of the above names as a variable name because it will disassociate the name to the corresponding built-in function, resulting in run-time errors that could be difficult to find.

In particular, the following names are common enough to be easily used in a program, so make the active effort **never to use them** as variable names.

str()
    sum()
    max()
    min()
    len()
    list()
    set()
    input()

## Building our Own Functions

- We create a new function using the **`def`** keyword followed by optional parameters in parentheses and a **`:`** (colon) at the end
- We **_indent_ the body** of the function (this is important)
- This defines the function but does not execute the body of the function

temperature = -10
season = 'winter'
print(season)

def friend():
    print("Winter, spring, summer or fall.")
    print("And I'll be there.")

temperature = 36
season = 'summer'
print(season)
print(temperature)

#あ

## Calling or Invoking Functions

Once we have defined a function, we can **call** (or invoke) it as many times as we like

friend()
friend()
friend()

#あ

## Parameters

A **parameter** is a variable which we use in the function definition.  It is a **handle** that allows the code in the function to access the **arguments** for a particular function invocation.

- Parameters: A variable used in the function `definition`
- Arguments: inputs to the function in a function `call`

def call_a_friend(season):
    if season =='winter':
        friend()
        print("Yes, I will.")
    elif season == 'spring':
        friend()
        print("Oh, yeah!")
    elif season is 'summer':
        friend()
        print("Ain't it good to know?")
    elif season is 'fall':
        friend()
        print("You've got a friend!")
    else:
        print('Who u?')

#あ

call_a_friend('winter')

call_a_friend('fall')

call_a_friend('rainy')

## Return Values

The **`return`** statement ends the function execution and *sends back* the result of the function

def greet(lang):
    if lang == 'es':
        return 'Hola'
    elif lang == 'fr':
        return 'Bonjour'
    else:
        return 'Hello'

greet('es')

spanish = greet('es')

print(spanish + ' Glenn')

print(greet('fr') + ' Sally')

print(greet('en') + ' Michael')

## Multiple Parameters / Arguments

- We can define more than one parameter in the function definition
- We simply add more arguments when we call the function
- We match the number and order of arguments and parameters

def addtwo(a, b):
    added = a + b
    return added

x = addtwo(3, 5)
print(x)

## Default argument and keyword arguments
[JRJ]

In a definition of a function, we can give default values to the arguments the function takes:

def myfunc(x, p=2, debug=False):
    if debug:
        print("evaluating myfunc for x = " + str(x) + " using exponent p = " + str(p))
    return x**p

If we don't provide a value of the `debug` argument when calling the the function `myfunc` it defaults to the value provided in the function definition:

#あ default parameters not provided
#あ  the function will use the default values p=2 and debug=False
myfunc(5)

myfunc(5, debug=True)

If we explicitly list the name of the arguments in the function calls, they do not need to come in the same order as in the function definition. This is called `keyword arguments`, and is often very useful in functions that takes a lot of optional arguments.

myfunc(p=3, debug=True, x=7)

## Why use functions?
[PEW]

It may not be clear why it is worth the trouble to divide a program into functions. There are several reasons:

- Creating a new function gives you an opportunity to name a group of statements, which makes your program easier to read, understand, and debug.

- Functions can make a program smaller by eliminating repetitive code. Later, if you make a change, you only have to make it in one place.

- Dividing a long program into functions allows you to debug the parts one at a time and then assemble them into a working whole.

- Well-designed functions are often useful for many programs. Once you write and debug one, you can reuse it.

## Final Words

Functions allow you to re-use previously-written code (by you, or by somebody else). You need to understand well how functions work in order to take advantage of the extensive library of functions in Python.<br>
Libraries (or modules) exist for:
- Scientific Computing
- Data manipulation
- Plotting
- Machine Learning

## EXERCISES

#### Exercise 1

Rewrite your pay computation with time-and-a-half for overtime and create a function called compute pay which takes two parameters (hours and rate).

    Enter Hours: 45
    Enter Rate: 10
    Pay: 475.0
    
[PEW] E4.6

## CHALLENGE

#### Challenge

Write a function called computegrade that takes a score as its parameter and returns a grade as a string using the following table:

    Score           Grade
    [ 97, 100]      1.0
    [ 93,  97)		1.25
    [ 89,  93)		1.5
    [ 85,  89)		1.75
    [ 81,  85)		2.0
    [ 77,  81)		2.25
    [ 74,  77)		2.5
    [ 0,   74)		3.0

    Run the program repeatedly to test the various different values for input.
    
Adapted from [PEW] E4.6
<br>

[TABLE OF CONTENTS](#contents)

<a id='chapter5'></a>

# CHAPTER  5 - ITERATIONS

Computers are often used to automate repetitive tasks. Repeating identical or similar tasks without making errors is something that computers do well and people do poorly. Because **iteration** is so common, Python provides several language features to make it easier. [PEW]

## Indefinite Loops with `while`

**`While`** loops are called **indefinite loops** because they keep going until  a logical condition becomes **`False`**

n = 5
while n > 0 :
    print(n)
    n = n - 1
print('Blastoff!')
print(n)

More formally, here is the flow of execution for a `while` statement:

- Evaluate the condition, yielding `True` or `False`.
- If the condition is false, exit the while statement and continue execution at the next statement.
- If the condition is true, execute the body and then go back to step 1.

![while_loop_2.jpg](attachment:while_loop_2.jpg)

This type of flow is called a **loop** because the third step loops back around to the top. We call each time we execute the body of the loop an **iteration**. For the above loop, we would say, "It had five iterations", which means that the body of the loop was executed five times.

The body of the loop should change the value of one or more variables so that eventually the condition becomes false and the loop terminates. We call the variable that changes each time the loop executes and controls when the loop finishes the **iteration variable**. If there is no iteration variable, the loop will repeat forever, resulting in an **infinite loop**. [PEW]

## `Break` and `Continue` in Loops

### Breaking Out of a Loop with `break`

Sometimes you don't know it's time to end a loop until you get half way through the body. In that case you can write an infinite loop on purpose and then use the break statement to jump out of the loop. [PEW]

while True:
    line = input('> ')
    if line == 'done' :
        break
    print(line)
print('Done!')

![break_2.jpg](attachment:break_2.jpg)

### Finishing an Iteration with `continue`

Here is an example of a loop that copies its input until the user types "done", but treats lines that start with the hash character as lines not to be printed (kind of like Python comments).

while True:
    line = input('> ')
    if line[0] == '#' :
        continue
    if line == 'done' :
        break
    print(line)
print('Done!')

![continue_2.jpg](attachment:continue_2.jpg)

If you run the code, all the lines are printed except the one that starts with the hash sign because when the `continue` is executed, it ends the current iteration and jumps back to the while statement to start the next iteration, thus skipping the `print` statement.

## Definite Loops with `for`

Sometimes we want to loop through a set of things such as a list of words, the lines in a file, or a list of numbers. When we have a list of things to loop through, we can construct a **definite loop** using a **`for`** statement. We call the while statement an indefinite loop because it simply loops until some condition becomes False, whereas the **for loop** is looping through a known set of items so it runs through as many iterations as there are items in the set. [PEW]

### A Simple Definite Loop

for i in [5, 4, 3, 2, 1]:
    print(i)
print('Blastoff!')

![for_loop_2.jpg](attachment:for_loop_2.jpg)

### A Definite Loop with Strings

friends = ['Joseph', 'Glenn', 'Sally']
for friend in friends:
   print('Happy New Year:', friend)
print('Done!')

In Python terms, the variable `friends` is a **`list`** of three strings and the for loop goes through the list and executes the body once for each of the three strings in the list resulting in this output:

In particular, `friend` is the iteration variable for the `for` loop. The variable `friend` changes for each iteration of the loop and controls when the `for` loop completes. The iteration variable steps successively through the three strings stored in the `friends` variable.

### A for loop with a List of Numbers

print('Before')
for num in [1, 2, 3, 5, 8, 13]:
     print(num)
print('After')

## Example Tasks with Solved by Using Loops

Often we use a `for` or `while` loop to go through a list of items or the contents of a file and we are looking for something such as the largest or smallest value of the data we scan through.

These loops are generally constructed by:

- Initializing one or more variables before the loop starts
- Performing some computation on each item in the loop body, possibly changing the variables in the body of the loop
- Looking at the resulting variables when the loop completes

We will use a list of numbers to demonstrate the concepts and construction of these loop patterns. [PEW]

Note: The codes below are mainly from [PEW]. The variable names have been edited to make the code more readable.

### Finding the Largest Value

largest_so_far = -1
print('Before', largest_so_far)
for num in [9, 41, 12, 3, 74, 15]:
   if num > largest_so_far :
      largest_so_far = num
   print(largest_so_far, num)

### Counting in a Loop

count = 0
print('Before', count)
for num in [9, 41, 12, 3, 74, 15]:
    count = count + 1
    print(count, num)
print('After', count)

### Summing in a Loop

total = 0
print('Before', total)
for item in [9, 41, 12, 3, 74, 15]:
    total = total + num
    print(total, num)
print('After', total)

#あ Note that you could have chosen the variable name sum.
#   However, sum is actually a built-in function in python.

### Finding the Average in a Loop

count = 0
total = 0
print('Before', count, total)
for num in [9, 41, 12, 3, 74, 15]:
    count = count + 1
    total = total + num
    print(count, total, num)
print('After', count, total, total / count)

### Filtering in a Loop

print('Before')
for value in [9, 41, 12, 3, 74, 15]:
    if value > 20:
        print('Large number',value)
print('After')

### Search Using a Boolean Variable

found = False
print('Before', found)
for value in [9, 41, 12, 3, 74, 15]:
   if value == 3 :
       found = True
   print(found, value)
print('After', found)

### How to Find the Largest Value

largest_so_far = -1
print('Before', largest_so_far)
for the_num in [9, 41, 12, 3, 74, 15]:
   if the_num > largest_so_far :
      largest_so_far = the_num
   print(largest_so_far, the_num)

print('After', largest_so_far)

### How to Find the Smallest Value using `None`

smallest = None
print('Before')
for value in [9, 41, 12, 3, 74, 15]:
    if smallest is None :
        smallest = value
    elif value < smallest :
        smallest = value
    print(smallest, value)
print('After', smallest)

## Final Words

- Loops give you the power to process in a *pipeline* large amounts of similar or related data
- Most loops in python are done using `for` loops
- Adapt the code snippets discussed in the latter part of this section to solve similar problems later on.

## EXERCISES

#### Exercise 1

Investigate on the difference between `is` and `==` given the following variables.
```python
a = 2
b = 2.0
c = a
```

## CHALLENGES

#### Challenge 1

Write a program which repeatedly reads numbers until the user enters "done". Once "done" is entered, print out the total, count, and average of the numbers. If the user enters anything other than a number, detect their mistake using try and except and print an error message and skip to the next number.

    Enter a number: 4
    Enter a number: 5
    Enter a number: bad data
    Invalid input
    Enter a number: 7
    Enter a number: done
    16 3 5.333333333333333
    
[PEW] E5.1

#### Challenge 2

Write another program that prompts for a list of numbers as above and at the end prints out both the maximum and minimum of the numbers instead of the average.

[PEW] E5.2

[TABLE OF CONTENTS](#contents)

<a id='chapter6'></a>
"""